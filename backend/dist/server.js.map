{"version":3,"sources":["../src/server.ts","../src/configs/envVars.ts","../src/configs/db.ts","../src/configs/passport.ts","../src/models/userModel.ts","../src/controllers/authController.ts","../src/utils/token.ts","../src/middlewares/validate.ts","../src/validations/authSchema.ts","../src/routes/authRoutes.ts","../src/routes/blogRoutes.ts","../src/models/blogModel.ts","../src/configs/imagekit.ts","../src/utils/uploadToImageKit.ts","../src/models/commentModel.ts","../src/configs/gemini.ts","../src/controllers/blogController.ts","../src/middlewares/authenticateJWT.ts","../src/validations/blogSchema.ts","../src/middlewares/multer.ts","../src/controllers/commentController.ts","../src/validations/commentSchema.ts","../src/routes/commentRoutes.ts","../src/routes/newsletterRoutes.ts","../src/models/NewsletterSubscriberModel.ts","../src/controllers/newsletterController.ts","../src/validations/newsletterSchema.ts"],"sourcesContent":["import express from \"express\";\nimport cors from \"cors\";\nimport { ENV_VARS } from \"./configs/envVars.ts\";\nimport connectDB from \"./configs/db.ts\";\nimport { configurePassport } from \"./configs/passport.ts\";\nimport cookieParser from \"cookie-parser\";\nimport passport from \"passport\";\nimport authRoutes from \"./routes/authRoutes.ts\";\nimport blogsRoutes from \"./routes/blogRoutes.ts\";\nimport commentsRoutes from \"./routes/commentRoutes.ts\";\nimport newsletterRoutes from \"./routes/newsletterRoutes.ts\";\n\nconst app = express();\nconfigurePassport();\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\napp.use(cookieParser());\n\n// Middleware to handle CORS\napp.use(cors({\n    origin: [ENV_VARS.FRONTEND_URI],\n    methods: [\"GET\", \"POST\", \"PATCH\", \"DELETE\"],\n    allowedHeaders: [\"Content-Type\", \"Authorization\"],\n    credentials: true\n}))\napp.use(passport.initialize());\nconnectDB()\n\napp.use(\"/api/v1/auth\", authRoutes);\napp.use(\"/api/v1/blogs\", blogsRoutes);\napp.use(\"/api/v1/comments\", commentsRoutes);\napp.use(\"/api/v1/newsletter\", newsletterRoutes);\n\n\n//app.listen(ENV_VARS.PORT, \"0.0.0.0\", () => {\n//    console.log(`✅ App is running on http://localhost:${ENV_VARS.PORT}`);\n//    connectDB();\n//})\n\nexport default app;","import dotenv from \"dotenv\";\ndotenv.config();\n\nexport const ENV_VARS = {\n    PORT: Number(process.env.PORT) || 5000,\n    NODE_ENV: (process.env.NODE_ENV || \"development\") as (\"development\" | \"production\"),\n    MONGO_URI: process.env.MONGO_URI || \"mongodb://localhost:27017/quickblog\",\n    FRONTEND_URI: process.env.FRONTEND_URI || \"http://localhost:5173\",\n    JWT_SECRET: process.env.JWT_SECRET || \"jwt_secret\",\n    REFRESH_SECRET: process.env.REFRESH_SECRET || \"refresh_secret\",\n    IMAGEKIT_PUBLIC_KEY: process.env.IMAGEKIT_PUBLIC_KEY || \"\",\n    IMAGEKIT_PRIVATE_KEY: process.env.IMAGEKIT_PRIVATE_KEY || \"\",\n    IMAGEKIT_URL_ENDPOINT: process.env.IMAGEKIT_URL_ENDPOINT || \"\",\n    GEMINI_API_KEY: process.env.GEMINI_API_KEY || \"\"\n} as const\n","import { connect } from \"mongoose\";\nimport { ENV_VARS } from \"./envVars\";\n\n\nexport default async function connectDB() {\n    try {\n        await connect(ENV_VARS.MONGO_URI);\n        console.log(\"✅ Connected to MongoDB successfully\");\n    } catch (err) {\n        console.error(\"❌ Failed to connect to MongoDB:\", err);\n        process.exit(1);\n    }\n}","import passport from \"passport\";\nimport { User } from \"@/models/userModel.ts\";\nimport { Strategy as JwtStrategy, ExtractJwt } from \"passport-jwt\";\nimport { ENV_VARS } from \"./envVars.ts\";\n\nconst opts = {\n    jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n    secretOrKey: ENV_VARS.JWT_SECRET\n} as const\n\nexport const configurePassport = () => {\n    passport.use(new JwtStrategy(opts, async (jwt_payload, done) => {\n        try {\n            const user = await User.findById(jwt_payload.id)\n                .select(\"-password\")\n                .lean();\n            if (user) return done(null, user);\n            return done(null, false);\n        }\n        catch (err) {\n            return done(err, false);\n        }\n    }))\n}","import { model, Schema, Document, Types } from \"mongoose\";\n\n\nexport interface IUser extends Document<Types.ObjectId> {\n    name: string;\n    email: string;\n    password: string\n}\n\n\nconst userSchema = new Schema<IUser>({\n    name: {\n        type: String,\n        required: [true, \"Name is required\"]\n    },\n    email: {\n        type: String,\n        required: true,\n        unique: [true, \"Email is required\"]\n    },\n    password: {\n        type: String,\n        required: [true, \"password is required\"]\n    }\n}, { timestamps: true })\n\n\nexport const User = model(\"User\", userSchema);","import type { Request, Response } from \"express-serve-static-core\";\nimport { User } from \"@/models/userModel.ts\";\nimport bcrypt, { compare } from \"bcrypt\";\nimport { ENV_VARS } from \"@/configs/envVars.ts\";\nimport { generateAccessToken, generateRefreshToken } from \"@/utils/token.ts\";\nimport jwt from \"jsonwebtoken\";\nimport type { LoginInput, RegisterInput } from \"@/validations/authSchema.ts\";\n\n\nexport const register = async (req: Request<{}, {}, RegisterInput>, res: Response) => {\n    const { name, email, password } = req.body;\n\n    try {\n        const existingUser = await User.findOne({ email });\n\n        if (existingUser) {\n            res.status(400).json({\n                success: false,\n                message: \"Email already exists\"\n            })\n            return;\n        }\n\n        const hashedPassword = await bcrypt.hash(password, 10);\n        const user = await User.create({\n            name,\n            email,\n            password: hashedPassword\n        })\n\n        const accessToken = generateAccessToken(user._id.toString());\n        const refreshToken = generateRefreshToken(user._id.toString());\n\n        res.cookie(\"refreshToken\", refreshToken, {\n            httpOnly: true,\n            secure: ENV_VARS.NODE_ENV === \"production\",\n            sameSite: \"strict\",\n            maxAge: 7 * 24 * 60 * 60 * 1000\n        })\n\n        res.status(201).json({\n            success: true,\n            message: \"User registered successfully\",\n            user: {\n                id: user._id,\n                name: user.name,\n                email: user.email\n            },\n            accessToken\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const login = async (req: Request<{}, {}, LoginInput>, res: Response) => {\n    const { email, password } = req.body;\n\n    try {\n        const user = await User.findOne({ email });\n\n        if (!user || !(await compare(password, user.password))) {\n            res.status(401).json({\n                success: false,\n                message: \"Invalid credentials\"\n            })\n            return;\n        }\n\n        const accessToken = generateAccessToken(user._id.toString());\n        const refreshToken = generateRefreshToken(user._id.toString());\n\n        res.cookie(\"refreshToken\", refreshToken, {\n            httpOnly: true,\n            secure: ENV_VARS.NODE_ENV === \"production\",\n            sameSite: \"strict\",\n            maxAge: 7 * 24 * 60 * 60 * 1000\n        })\n\n        res.status(201).json({\n            success: true,\n            message: \"User logged in successfully\",\n            user: {\n                id: user._id,\n                name: user.name,\n                email: user.email\n            },\n            accessToken\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const refreshToken = (req: Request, res: Response) => {\n    const token = req.cookies.refreshToken as string;\n\n    if (!token) {\n        res.status(401).json({\n            success: false,\n            message: \"No refresh token provided\"\n        })\n        return;\n    }\n    try {\n        jwt.verify(token, ENV_VARS.REFRESH_SECRET, async (err: any, decoded: any) => {\n            if (err) {\n                res.status(403).json({\n                    success: false,\n                    message: \"Invalid refresh token\"\n                })\n                return;\n            }\n\n            const user = await User.findById(decoded.id)\n                .select(\"-password\")\n                .lean();\n\n            if (!user) {\n                res.status(404).json({\n                    success: false,\n                    message: \"User not found\"\n                })\n                return;\n            }\n\n            const newAccessToken = generateAccessToken(decoded.id);\n            res.status(200).json({\n                success: true,\n                accessToken: newAccessToken,\n                user: {\n                    id: user._id,\n                    name: user.name,\n                    email: user.email\n                }\n            })\n        })\n    }\n    catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const logout = (req: Request, res: Response) => {\n    const refreshToken = req.cookies.refreshToken as string;\n\n    if (!refreshToken) {\n        res.status(400).json({\n            success: false,\n            message: \"No active session found, user is already logged out\"\n        })\n        return;\n    }\n\n    res.clearCookie(\"refreshToken\", {\n        httpOnly: true,\n        sameSite: \"strict\",\n        secure: ENV_VARS.NODE_ENV === \"production\"\n    })\n\n    res.status(200).json({\n        success: true,\n        message: \"Logged out successfully\"\n    })\n}","import { ENV_VARS } from \"@/configs/envVars.ts\";\nimport jwt from \"jsonwebtoken\";\n\nexport const generateAccessToken = (userId: string) => {\n    return jwt.sign({ id: userId }, ENV_VARS.JWT_SECRET, {\n        expiresIn: \"15m\"\n    })\n}\n\nexport const generateRefreshToken = (userId: string) => {\n    return jwt.sign({ id: userId }, ENV_VARS.REFRESH_SECRET, {\n        expiresIn: \"7d\"\n    })\n}","import { Request, Response, NextFunction } from \"express-serve-static-core\";\nimport { AnyZodObject } from \"zod\";\n\n\ntype ValidateOptions = {\n    body?: AnyZodObject,\n    query?: AnyZodObject,\n    params?: AnyZodObject\n}\n\n/**\n * Middleware to validate request body, query, and params using Zod schemas.\n * \n * @param schema - An abject containing optional Zod schemas for body, query, and params.\n * @returns Express middleware function\n * \n * If validation fails, it responds with a 400 status and validation errors.\n */\nexport const validate = (schema: ValidateOptions) =>\n    (req: Request, res: Response, next: NextFunction) => {\n        try {\n            if (schema.body) {\n                const result = schema.body.safeParse(req.body);\n                if (!result.success) {\n                    res.status(400).json({\n                        success: false,\n                        message: \"Validation error\",\n                        errors: result.error.errors.map(err => ({\n                            field: err.path.join(\".\"),\n                            msg: err.message\n                        }))\n                    })\n                    return;\n                }\n\n                req.body = result.data;\n            }\n\n            if (schema.query) {\n                const result = schema.query.safeParse(req.query);\n                if (!result.success) {\n                    res.status(400).json({\n                        success: false,\n                        errors: result.error.errors.map(err => ({\n                            field: err.path.join(\".\"),\n                            msg: err.message\n                        }))\n                    })\n                    return;\n                }\n\n                req.query = result.data;\n            }\n\n            if (schema.params) {\n                const result = schema.params.safeParse(req.params);\n                if (!result.success) {\n                    res.status(400).json({\n                        success: false,\n                        errors: result.error.errors.map(err => ({\n                            field: err.path.join(\".\"),\n                            msg: err.message\n                        }))\n                    })\n                    return;\n                }\n\n                req.params = result.data;\n            }\n            next()\n        } catch (err) {\n            res.status(500).json({\n                success: false,\n                message: \"Validation middleware failed unexpectedly\",\n            });\n            return;\n        }\n    }","import { z } from \"zod\";\n\nexport const registerSchema = z.object({\n    name: z.string({\n        required_error: \"Name is required\"\n    }).min(3, \"name must be at least 3 characters\"),\n\n    email: z.string({\n        required_error: \"Email is required\"\n    }).email(\"Invalid email format\"),\n\n    password: z.string({\n        required_error: \"Password is required\"\n    }).min(6, \"Password must be at least 6 characters\")\n})\n\n\nexport const loginSchema = z.object({\n    email: z.string({\n        required_error: \"Email is required\"\n    }).email(\"Invalid email format\"),\n\n    password: z.string({\n        required_error: \"Password is required\"\n    }).min(6, \"Password must be at least 6 characters\")\n})\n\n\nexport type RegisterInput = z.infer<typeof registerSchema>;\nexport type LoginInput = z.infer<typeof loginSchema>;\n","import * as AuthController from \"@/controllers/authController.ts\";\nimport { validate } from \"@/middlewares/validate.ts\";\nimport { loginSchema, registerSchema } from \"@/validations/authSchema.ts\";\nimport { Router } from \"express\";\n\nconst router = Router();\n\n/**\n * @route POST /api/v1/auth/register\n * @desc register a new user\n * @access Public\n * @body { name: string, email: string, password: string }\n */\nrouter.post(\n    \"/register\",\n    validate({ body: registerSchema }),\n    AuthController.register\n);\n\n/**\n * @route POST /api/v1/auth/login\n * @desc Log in an existing user\n * @access Public\n * @body { email: string, password: string }\n */\nrouter.post(\n    \"/login\",\n    validate({ body: loginSchema }),\n    AuthController.login\n);\n\n/**\n * @route POST /api/v1/auth/refresh-token\n * @desc Refresh JWT access token using refresh token\n * @access Public (requires valid refresh token in cookie)\n */\nrouter.post(\n    \"/refresh-token\",\n    AuthController.refreshToken\n);\n\n/**\n * @route POST /api/v1/auth/logout\n * @desc Log out user and clear refresh token cookie\n * @access Public\n */\nrouter.post(\n    \"/logout\",\n    AuthController.logout\n);\n\n\nexport default router;","import { Router } from \"express\";\nimport * as BlogController from \"@/controllers/blogController.ts\";\nimport { authenticateJWT } from \"@/middlewares/authenticateJWT.ts\";\nimport { validate } from \"@/middlewares/validate.ts\";\nimport { createBlogSchema, generateDescriptionSchema, updateBlogSchema } from \"@/validations/blogSchema.ts\";\nimport { upload } from \"@/middlewares/multer.ts\";\n\nconst router = Router();\n\n\n/**\n * @route GET /api/v1/blogs/author\n * @desc Get all blogs created by the logged-in author (paginated)\n * @access Private\n * @query { limit? number, page?: number }\n */\nrouter.get(\n    \"/author\",\n    authenticateJWT,\n    BlogController.getBlogsForAuthor\n);\n\n\n/**\n * @route GET /api/v1/blogs/dashboard\n * @desc Get dashboard statistics (total blogs, total comments, latest 6 blogs)\n * @access Private \n */\nrouter.get(\n    \"/dashboard\",\n    authenticateJWT,\n    BlogController.getDashboardStats\n)\n\n\n/**\n * @route GET /api/v1/blogs/category/:category\n * @desc Get published blogs filtered by category (paginated)\n * @access Public\n * @params { category: BlogCategory }\n * @query { limit?:number, page?: number }\n */\nrouter.get(\n    \"/category/:category\",\n    BlogController.getBlogsByCategory\n);\n\n\n/**\n * @route GET /api/v1/blogs/:id\n * @desc Get a single blog post by ID\n * @access Private\n * @params { id: string }\n */\nrouter.get(\n    \"/:id\",\n    BlogController.getBlogById\n);\n\n\n/**\n * @route POST /api/v1/blogs\n * @desc Create a new blog post by an authenticated author\n * @access Private\n * @body { title, subTitle, description, category, image }\n */\nrouter.post(\n    \"/\",\n    authenticateJWT,\n    upload.single(\"image\"),\n    validate({ body: createBlogSchema }),\n    BlogController.createBlog\n);\n\n\n/**\n * @route POST /api/v1/blogs/generate-description\n * @desc Generate a blog description using AI based on prompt\n * @access Private\n */\nrouter.post(\n    \"/generate-description\",\n    authenticateJWT,\n    validate({ body: generateDescriptionSchema }),\n    BlogController.generateDescription\n)\n\n/**\n * @route PATCH /api/v1/blogs/:id/published\n * @desc Toggle the `isPublished` status of a blog post (publish/unpublish)\n * @access Private (only the author can toggle)\n * @params { id: string } - ID of the blog post to toggle\n */\nrouter.patch(\n    \"/:id/publish\",\n    authenticateJWT,\n    BlogController.togglePublish\n);\n\n\n/**\n * @route PUT /api/v1/blogs/:id\n * @desc Update a blog post by ID\n * @access Private (only the author can update)\n * @params { id: string }\n */\nrouter.patch(\n    \"/:id\",\n    authenticateJWT,\n    upload.single(\"image\"),\n    validate({ body: updateBlogSchema }),\n    BlogController.updateBlog\n);\n\n\n/**\n * @route DELETE /api/v1/blogs/:id\n * @desc Delete a blog post by ID (only by its author)\n * @access Private\n * @params { id: string }\n */\nrouter.delete(\n    \"/:id\",\n    authenticateJWT,\n    BlogController.deleteBlog\n)\n\n\nexport default router;","import { model, Schema, Types, Document } from \"mongoose\";\n\nexport const blogCategories = ['startup', 'technology', 'lifestyle', 'finance'] as const;\nexport type BlogCategory = typeof blogCategories[number];\n\nexport interface IBlog extends Document<Types.ObjectId> {\n    author: Types.ObjectId;\n    title: string;\n    subTitle: string;\n    description: string;\n    category: BlogCategory;\n    image: string;\n    isPublished: boolean\n}\n\n\nconst blogSchema = new Schema<IBlog>({\n    author: {\n        type: Schema.Types.ObjectId,\n        ref: \"User\",\n        required: [true, \"Author id is required\"]\n    },\n    title: {\n        type: String,\n        required: [true, \"Title is required\"]\n    },\n    subTitle: {\n        type: String,\n        required: [true, \"Subtitle is required\"]\n    },\n    description: {\n        type: String,\n        required: [true, \"Description is required\"]\n    },\n    category: {\n        type: String,\n        enum: blogCategories,\n        required: [true, \"Category is required\"]\n    },\n    image: {\n        type: String,\n        required: [true, \"Image is required\"]\n    },\n    isPublished: {\n        type: Boolean,\n        default: false\n    }\n}, { timestamps: true })\n\n\nexport const Blog = model(\"Blog\", blogSchema);\n","import ImageKit from \"imagekit\";\nimport { ENV_VARS } from \"./envVars.ts\";\n\n\nconst imagekit = new ImageKit({\n    publicKey: ENV_VARS.IMAGEKIT_PUBLIC_KEY,\n    privateKey: ENV_VARS.IMAGEKIT_PRIVATE_KEY,\n    urlEndpoint: ENV_VARS.IMAGEKIT_URL_ENDPOINT\n});\n\nexport default imagekit;","import imagekit from \"@/configs/imagekit.ts\";\n\nexport const uploadImageAndGetOptimizedUrl = async (\n    buffer: Buffer,\n    fileName: string\n): Promise<string> => {\n\n    const uploadResponse = await imagekit.upload({\n        file: buffer,\n        fileName,\n        folder: \"/blogs\"\n    })\n\n    // return optimized URL\n    return imagekit.url({\n        path: uploadResponse.filePath,\n        transformation: [\n            { quality: \"auto\" },\n            { format: \"webp\" },\n            { width: \"1280\" }\n        ]\n    });\n};","import { model, Schema, Types, Document } from \"mongoose\";\n\nexport interface ICommentDocument extends Document<Types.ObjectId> {\n    blog: Types.ObjectId;\n    name: string;\n    content: string;\n    isApproved: boolean\n}\n\n\nconst commentSchema = new Schema<ICommentDocument>({\n    blog: {\n        type: Schema.Types.ObjectId,\n        ref: \"Blog\",\n        required: [true, \"Blog id is required\"]\n    },\n    name: {\n        type: String,\n        required: [true, \"Name is required\"],\n        trim: true,\n        maxlength: 30\n    },\n    content: {\n        type: String,\n        required: [true, \"Content is required\"],\n        trim: true,\n        maxlength: 1000\n    },\n    isApproved: {\n        type: Boolean,\n        default: false\n    }\n}, { timestamps: true })\n\n\nexport const Comment = model(\"Comment\", commentSchema);","import { GoogleGenAI } from \"@google/genai\";\nimport { ENV_VARS } from \"./envVars\";\n\nconst ai = new GoogleGenAI({ apiKey: ENV_VARS.GEMINI_API_KEY });\n\nasync function generateBlogDescription(prompt: string) {\n    const response = await ai.models.generateContent({\n        model: \"gemini-2.0-flash\",\n        contents: prompt,\n    });\n\n    return response.candidates?.[0].content || \"\";\n}\n\nexport default generateBlogDescription;","import type { Request, Response } from \"express-serve-static-core\";\nimport { Blog, type BlogCategory } from \"@/models/blogModel.ts\";\nimport { type CreateBlogInput, type UpdateBlogInput } from \"@/validations/blogSchema.ts\";\nimport { uploadImageAndGetOptimizedUrl } from \"@/utils/uploadToImageKit.ts\";\nimport { Comment } from \"@/models/commentModel.ts\";\nimport generateBlogDescription from \"@/configs/gemini\";\ntype ExtendedCategory = BlogCategory | \"all\";\n\n\nexport const getBlogsForAuthor = async (req: Request<{}, {}, {}, { limit?: number, page?: number }>, res: Response) => {\n    try {\n        const limit = Number(req.query.limit) || 10;\n        const page = Number(req.query.page) || 1;\n        const skip = (page - 1) * limit;\n\n        const authorId = (req.user as { _id: string })._id;\n\n        const totalBlogs = await Blog.countDocuments({ author: authorId });\n        const totalPages = Math.ceil(totalBlogs / limit);\n\n        const blogs = await Blog.find({ author: authorId })\n            .select(\"title isPublished createdAt\")\n            .sort({ createdAt: -1 })\n            .skip(skip)\n            .limit(limit)\n            .lean();\n\n        res.status(200).json({\n            success: true,\n            message: `Fetched blogs for author - page ${page} of ${totalPages}`,\n            data: blogs,\n            pagination: {\n                currentPage: page,\n                totalPages,\n                pageSize: limit,\n                hasNextPage: page < totalPages,\n                hasPrevPage: page > 1\n            }\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const getDashboardStats = async (req: Request, res: Response) => {\n    try {\n        const authorId = (req.user as { _id: string })._id.toString();\n\n        // Fetch author blog IDs and blog-related counts in parallel\n        const [authorBlogIds, totalBlogs, totalDrafts] = await Promise.all([\n            Blog.find({ author: authorId }).distinct(\"_id\"),\n            Blog.countDocuments({ author: authorId }),\n            Blog.countDocuments({ author: authorId, isPublished: false })\n        ]);\n\n        const [totalComments, latestBlogs] = await Promise.all([\n            Comment.countDocuments({ blog: { $in: authorBlogIds } }),\n            Blog.find({ author: authorId })\n                .sort({ createdAt: -1 })\n                .limit(6)\n                .select(\"title createdAt isPublished\")\n                .lean()\n        ]);\n\n        res.status(200).json({\n            success: true,\n            message: \"Dashboard statistics fetched successfully\",\n            data: {\n                totalBlogs,\n                totalComments,\n                totalDrafts,\n                latestBlogs\n            }\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const getBlogsByCategory = async (req: Request<{ category: ExtendedCategory }, {}, {}, { limit?: number, page?: number, q?: string }>, res: Response) => {\n    try {\n        const { category } = req.params;\n        const limit = Number(req.query.limit) || 10;\n        const page = Number(req.query.page) || 1;\n        const skip = (page - 1) * limit;\n        const query = req.query.q?.trim();\n\n        const filter: Record<string, any> = { isPublished: true };\n\n        if (category !== \"all\") {\n            filter.category = category;\n        }\n\n        if (query) {\n            filter.$or = [\n                { title: { $regex: query, $options: \"i\" } },\n                { subTitle: { $regex: query, $options: \"i\" } }\n            ];\n        }\n\n        const totalBlogs = await Blog.countDocuments(filter);\n        const totalPages = Math.ceil(totalBlogs / limit);\n\n        const blogs = await Blog.find(filter)\n            .select(\"title description category image\")\n            .sort({ createdAt: -1 })\n            .skip(skip)\n            .limit(limit)\n            .lean();\n\n        res.status(200).json({\n            success: true,\n            message: category === \"all\"\n                ? `All blogs retrieved successfully`\n                : `Blogs in category '${category}' retrieved successfully`,\n            data: blogs,\n            pagination: {\n                currentPage: page,\n                totalPages,\n                hasNextPage: page < totalPages,\n                hasPrevPage: page > 1\n            }\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const getBlogById = async (req: Request<{ id: string }>, res: Response) => {\n    try {\n        const blogId = req.params.id;\n\n        const blog = await Blog.findOne({ _id: blogId, isPublished: true })\n            .select(\"-isPublished -__v -updatedAt\")\n            .populate(\"author\", \"name\")\n            .lean();\n\n        if (!blog) {\n            res.status(404).json({\n                success: false,\n                message: \"Blog not found\"\n            })\n            return;\n        }\n\n        res.status(200).json({\n            success: false,\n            message: \"Blog fetched successfully\",\n            data: blog\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const createBlog = async (req: Request<{}, {}, CreateBlogInput>, res: Response) => {\n    try {\n        const authorId = (req.user as { _id: string })._id.toString();\n        const imageFile = req.file;\n\n        if (!imageFile) {\n            res.status(400).json({\n                success: false,\n                message: \"Validation error\",\n                errors: [\n                    {\n                        field: \"image\",\n                        msg: \"Image is required\"\n                    }\n                ]\n            })\n            return;\n        }\n\n        const optimizedImageUrl = await uploadImageAndGetOptimizedUrl(\n            imageFile.buffer,\n            imageFile.originalname\n        )\n\n        const blog = await Blog.create({\n            author: authorId,\n            image: optimizedImageUrl,\n            ...req.body\n        })\n\n        res.status(201).json({\n            success: true,\n            message: \"Blog created successfully\",\n            data: {\n                _id: blog._id,\n                category: blog.category\n            }\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const generateDescription = async (req: Request<{}, {}, { prompt: string }>, res: Response) => {\n    const { prompt } = req.body;\n\n    try {\n        const rawResponse = await generateBlogDescription(`generate a blog content for this topic: ${prompt} in simple text format`);\n        let description = \"\";\n\n        if (\n            rawResponse &&\n            typeof rawResponse === \"object\" &&\n            \"parts\" in rawResponse &&\n            Array.isArray((rawResponse as any).parts)\n        ) {\n            description = (rawResponse as any).parts?.[0]?.text || \"\";\n        }\n\n        res.status(200).json({\n            success: true,\n            message: \"Blog description generated successfully\",\n            data: { description }\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\n\nexport const togglePublish = async (req: Request<{ id: string }, {}, UpdateBlogInput>, res: Response) => {\n    try {\n        const authorId = (req.user as { _id: string })._id.toString();\n\n        const blog = await Blog.findById(req.params.id);\n\n        if (!blog) {\n            res.status(404).json({\n                success: false,\n                message: \"Blog not found\"\n            })\n            return;\n        }\n\n        if (blog.author.toString() !== authorId) {\n            res.status(403).json({\n                success: false,\n                message: \"You are not authorized to update this blog\"\n            })\n            return;\n        }\n\n        blog.isPublished = !blog.isPublished;\n        await blog.save();\n\n        res.status(200).json({\n            success: true,\n            message: `Blog ${blog.isPublished ? \"published\" : \"unpublished\"} successfully`,\n            data: {\n                _id: blog._id,\n                category: blog.category,\n                isPublished: blog.isPublished\n            }\n        });\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const updateBlog = async (req: Request<{ id: string }, {}, UpdateBlogInput>, res: Response) => {\n    try {\n        const authorId = (req.user as { _id: string })._id.toString();\n\n        const blog = await Blog.findById(req.params.id);\n\n        if (!blog) {\n            res.status(404).json({\n                success: false,\n                message: \"Blog not found\"\n            })\n            return;\n        }\n\n        if (blog.author.toString() !== authorId) {\n            res.status(403).json({\n                success: false,\n                message: \"You are not authorized to update this blog\"\n            })\n            return;\n        }\n\n        const imageFile = req.file;\n\n        if (imageFile) {\n            const optimizedImageUrl = await uploadImageAndGetOptimizedUrl(\n                imageFile.buffer,\n                imageFile.originalname\n            )\n\n            blog.image = optimizedImageUrl;\n        }\n\n        Object.assign(blog, req.body);\n\n        await blog.save();\n\n        res.status(200).json({\n            success: true,\n            message: \"Blog updated successfully\",\n            data: blog\n        });\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const deleteBlog = async (req: Request<{ id: string }>, res: Response) => {\n    try {\n        const blogId = req.params.id;\n        const userId = (req.user as { _id: string })._id.toString();\n\n        const blog = await Blog.findById(blogId).lean();\n\n        if (!blog) {\n            res.status(404).json({\n                success: false,\n                message: \"Blog not found\"\n            })\n            return;\n        }\n\n        if (blog.author.toString() !== userId) {\n            res.status(403).json({\n                success: false,\n                message: \"You are not authorized to delete this blog\"\n            })\n            return;\n        }\n\n        // Delete the blog\n        const deletedBlog = await Blog.findByIdAndDelete(blogId);\n\n        // Delete all comments related to this blog\n        await Comment.deleteMany({ blog: blogId });\n\n        res.status(200).json({\n            success: true,\n            message: \"Blog deleted successfully\",\n            data: {\n                _id: deletedBlog?._id,\n                category: deletedBlog?.category\n            }\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}","import { NextFunction, Request, Response } from \"express-serve-static-core\";\nimport passport from \"passport\";\n\n/**\n * Middleware to authenticate using JWT strategy with Passport\n */\nexport const authenticateJWT = (req: Request, res: Response, next: NextFunction) => {\n    passport.authenticate(\"jwt\", { session: false }, (err: any, user: any) => {\n        if (err) {\n            res.status(500).json({\n                success: false,\n                message: \"Internal Server Error when authenticating\"\n            })\n            return;\n        }\n\n        if (!user) {\n\n            res.status(401).json({\n                success: false,\n                message: \"Unauthorized\"\n            })\n            return;\n        }\n\n        req.user = user;\n        next()\n    })(req, res, next)\n}","import { blogCategories } from \"@/models/blogModel\";\nimport { z } from \"zod\";\n\n\nexport const createBlogSchema = z.object({\n    title: z.string({\n        required_error: \"Title is required\"\n    }).min(3, \"Title must be at least 3 characters\"),\n    subTitle: z.string({\n        required_error: \"SubTitle is required\"\n    }).min(3, \"SubTitle must be at least 3 characters\"),\n    description: z.string({\n        required_error: \"Description is required\"\n    }).min(10, \"Description must be at least 10 characters\"),\n    category: z.enum(blogCategories, {\n        required_error: \"Category is required\",\n        message: `Category must be one of these: ${blogCategories.join(\" | \")}`\n    }),\n    isPublished: z.union([\n        z.boolean(),\n        z.literal(\"true\").transform(() => true),\n        z.literal(\"false\").transform(() => false),\n    ])\n        .catch(false)\n        .default(false)\n});\n\nexport const generateDescriptionSchema = z.object({\n    prompt: z.string({ required_error: \"Prompt text is required\" })\n        .trim()\n        .min(10, \"Prompt must be at least 10 characters\"),\n});\n\n\nexport const updateBlogSchema = createBlogSchema.partial();\n\nexport type CreateBlogInput = z.infer<typeof createBlogSchema>;\nexport type UpdateBlogInput = z.infer<typeof updateBlogSchema>;\n","import multer from \"multer\";\n\nconst storage = multer.memoryStorage();\n\nexport const upload = multer({ storage });","import { Blog } from \"@/models/blogModel.ts\";\nimport { Comment } from \"@/models/commentModel.ts\";\nimport { type CreateCommentInput } from \"@/validations/commentSchema.ts\";\nimport type { Request, Response } from \"express-serve-static-core\";\nimport { Types } from \"mongoose\";\n\nexport const getAllComments = async (\n    req: Request<{}, {}, {}, { isApproved?: string; page?: number; limit?: number }>,\n    res: Response\n) => {\n    const limit = Number(req.query.limit) || 10;\n    const page = Number(req.query.page) || 1;\n    const skip = (page - 1) * limit;\n    const userId = (req.user as { _id: string })._id.toString();\n\n    const isApproved = req.query.isApproved === \"true\";\n\n    try {\n\n        const matchStage: any = {\n            ...(typeof req.query.isApproved === \"string\" ? { isApproved } : { isApproved: true }),\n        };\n\n        const comments = await Comment.aggregate([\n            { $match: matchStage },\n            {\n                $lookup: {\n                    from: \"blogs\",\n                    localField: \"blog\",\n                    foreignField: \"_id\",\n                    as: \"blog\",\n                },\n            },\n            { $unwind: \"$blog\" },\n            { $match: { \"blog.author\": new Types.ObjectId(userId) } },\n            {\n                $project: {\n                    content: 1,\n                    name: 1,\n                    isApproved: 1,\n                    createdAt: 1,\n                    blog: { _id: 1, title: 1 },\n                },\n            },\n            { $sort: { createdAt: -1 } },\n            { $skip: skip },\n            { $limit: limit },\n        ]);\n\n        const total = await Comment.aggregate([\n            { $match: matchStage },\n            {\n                $lookup: {\n                    from: \"blogs\",\n                    localField: \"blog\",\n                    foreignField: \"_id\",\n                    as: \"blog\",\n                },\n            },\n            { $unwind: \"$blog\" },\n            { $match: { \"blog.author\": new Types.ObjectId(userId) } },\n            { $count: \"total\" },\n        ]);\n\n        const totalCount = total[0]?.total || 0;\n        const totalPages = Math.ceil(totalCount / limit);\n\n        res.status(200).json({\n            success: true,\n            message: \"Comments fetched successfully\",\n            data: comments,\n            pagination: {\n                currentPage: page,\n                totalPages,\n                hasNextPage: page < totalPages,\n                hasPrevPage: page > 1,\n            },\n        });\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\",\n        });\n    }\n};\n\n\nexport const getApprovedCommentsForBlog = async (req: Request<{ blogId: string }>, res: Response) => {\n    const { blogId } = req.params;\n\n    try {\n\n        const blogExists = await Blog.exists({ _id: blogId });\n        if (!blogExists) {\n            res.status(404).json({\n                success: false,\n                message: \"Blog not found\"\n            })\n            return;\n        }\n\n        const comments = await Comment.find({\n            blog: blogId,\n            isApproved: true\n        }).select(\"-__v -blog -isApproved\")\n            .sort({ createdAt: -1 })\n            .lean()\n\n        res.status(200).json({\n            success: true,\n            message: `${comments.length} approved comment(s) found`,\n            data: comments\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const createComment = async (req: Request<{ blogId: string }, {}, CreateCommentInput>, res: Response) => {\n\n    const { blogId } = req.params;\n    const { name, content } = req.body;\n\n    try {\n        const blogExists = await Blog.exists({ _id: blogId });\n        if (!blogExists) {\n            res.status(404).json({\n                success: false,\n                message: \"Blog not found\"\n            })\n            return;\n        }\n\n        const comment = await Comment.create({\n            blog: blogId,\n            name,\n            content\n        })\n\n        res.status(201).json({\n            success: true,\n            message: \"Comment created successfully and pending approval\"\n        });\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const approveComment = async (req: Request<{ id: string }>, res: Response) => {\n    const commentId = req.params.id;\n    const userId = (req.user as { _id: string })._id.toString();\n\n    try {\n\n        // Find the comment\n        const comment = await Comment.findById(commentId);\n        if (!comment) {\n            res.status(404).json({\n                success: false,\n                message: \"Comment not found\"\n            })\n            return;\n        }\n\n        // Find the blog associated with the comment\n        const blog = await Blog.findById(comment.blog);\n        if (!blog) {\n            res.status(404).json({\n                success: false,\n                message: \"Blog associated with this comment not found\"\n            })\n            return;\n        }\n\n        // Check if the authenticated user is the blog's author\n        if (blog.author.toString() !== userId) {\n            res.status(403).json({\n                success: false,\n                message: \"You are not authorized to approve comments on this blog\"\n            })\n            return;\n        }\n\n        comment.isApproved = true;\n        await comment.save();\n\n        res.status(200).json({\n            success: true,\n            message: \"Comment approved successfully\",\n            data: {\n                commentId: comment._id,\n                blogId: blog._id\n            }\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const deleteComment = async (req: Request<{ id: string }>, res: Response) => {\n\n    const commentId = req.params.id;\n    const userId = (req.user as { _id: string })._id.toString();\n\n    try {\n\n        // find comment and populate blog's author\n        const comment = await Comment.findById(commentId)\n            .populate<{ blog: { author: string; _id: string } }>('blog', 'author');\n\n        if (!comment) {\n            res.status(404).json({\n                success: false,\n                message: \"Comment not found\"\n            })\n            return;\n        }\n\n        // Check if the authenticated user is the blog's author\n        if (comment.blog.author.toString() !== userId) {\n            res.status(403).json({\n                success: false,\n                message: \"You are not authorized to delete this comment\"\n            })\n            return;\n        }\n\n        await Comment.deleteOne({ _id: commentId });\n\n        res.status(200).json({\n            success: true,\n            message: \"Comment deleted successfully\",\n            data: {\n                _id: comment._id,\n                blogId: comment.blog._id,\n                isApproved: comment.isApproved\n            }\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}","import { z } from \"zod\";\n\n\nexport const createCommentSchema = z.object({\n    name: z.string({\n        required_error: \"Name is required\",\n        invalid_type_error: \"Name must be a string\"\n    })\n        .min(3, \"Name must be at least 3 characters\")\n        .max(30, \"Name must be at most 30 characters\"),\n\n    content: z.string({\n        required_error: \"Content is required\",\n        invalid_type_error: \"Content must be a string\"\n    })\n        .min(3, \"Content must be at least 3 characters\")\n        .max(1000, \"Content must be at most 100 characters\")\n})\n\nexport type CreateCommentInput = z.infer<typeof createCommentSchema>;","import * as CommentController from \"@/controllers/commentController.ts\";\nimport { authenticateJWT } from \"@/middlewares/authenticateJWT.ts\";\nimport { validate } from \"@/middlewares/validate.ts\";\nimport { createCommentSchema } from \"@/validations/commentSchema.ts\";\nimport { Router } from \"express\";\n\n\nconst router = Router();\n\n\n/**\n * @route GET /api/v1/comments\n * @desc Get all comments (optionally filter by approval status)\n * @access Private\n * @query ({ isApproved?: boolean, page?: number, limit?:number })\n */\nrouter.get(\n    \"/\",\n    authenticateJWT,\n    CommentController.getAllComments\n)\n\n\n/**\n * @route Get /api/v1/comments/blog/blogId\n * @desc Get all approved comments for a blog post\n * @access Public\n */\nrouter.get(\n    \"/blog/:blogId\",\n    CommentController.getApprovedCommentsForBlog\n)\n\n\n/**\n * @route POST /api/v1/comments/:blogId\n * @desc Create a new comment for a blog post\n * @access Public \n */\nrouter.post(\n    \"/:blogId\",\n    validate({ body: createCommentSchema }),\n    CommentController.createComment\n);\n\n\n/**\n * @route PATCH /api/v1/comments/:id/approve\n * @desc Approve a comment\n * @access Private\n */\nrouter.patch(\n    \"/:id/approve\",\n    authenticateJWT,\n    CommentController.approveComment\n)\n\n\n/**\n * @route DELETE /api/v1/comments/:id\n * @desc Delete a comment\n * @access Private\n */\nrouter.delete(\n    \"/:id\",\n    authenticateJWT,\n    CommentController.deleteComment\n)\n\n\nexport default router;","import { Router } from \"express\";\nimport * as NewsletterController from \"@/controllers/newsletterController.ts\";\nimport { authenticateJWT } from \"@/middlewares/authenticateJWT\";\nimport { validate } from \"@/middlewares/validate\";\nimport { subscribeSchema } from \"@/validations/newsletterSchema\";\n\nconst router = Router();\n\n\n/**\n * @route POST /api/v1/newsletter/subscribe\n * @desc Subscribe a user to the newsletter\n * @access Public\n * @body { email: string } - email address to subscribe\n */\nrouter.post(\n    \"/subscribe\",\n    validate({ body: subscribeSchema }),\n    NewsletterController.subscribeToNewsletter\n);\n\n\n/**\n * @route GET /api/v1/newsletter/subscribes\n * @desc Get paginated list of newsletter subscribers\n * @access Private (requires JWT authentication)\n * @query { page?: number, limit?: number } - pagination parameters\n */\nrouter.get(\n    \"/subscribers\",\n    authenticateJWT,\n    NewsletterController.getSubscribers\n)\n\n\nexport default router;","import { model, Schema, Document, Types } from \"mongoose\";\n\n\nexport interface INewsletterSubscriber extends Document<Types.ObjectId> {\n    email: string;\n    subscribedAt: Date\n}\n\n\nconst newsletterSubscriberSchema = new Schema<INewsletterSubscriber>({\n    email: {\n        type: String,\n        required: [true, \"Email is required\"],\n        unique: true,\n        lowercase: true,\n        trim: true\n    },\n    subscribedAt: {\n        type: Date,\n        default: Date.now\n    }\n}, { timestamps: true });\n\n\nexport const NewsletterSubscriber = model(\"NewsletterSubscriber\", newsletterSubscriberSchema);","import { NewsletterSubscriber } from \"@/models/NewsletterSubscriberModel.ts\";\nimport { SubscribeInput } from \"@/validations/newsletterSchema\";\nimport type { Response, Request } from \"express-serve-static-core\";\n\n\nexport const subscribeToNewsletter = async (req: Request<{}, {}, SubscribeInput>, res: Response) => {\n    const { email } = req.body;\n\n    try {\n\n        // check if already subscribed\n        const existing = await NewsletterSubscriber.findOne({ email });\n        if (existing) {\n            res.status(400).json({\n                success: false,\n                message: \"Email is already subscribed.\"\n            })\n            return;\n        }\n\n        // create new subscription\n        const subscriber = new NewsletterSubscriber({ email });\n        await subscriber.save();\n\n        res.status(201).json({\n            success: true,\n            message: \"Successfully subscribed to the newsletter.\"\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}\n\n\nexport const getSubscribers = async (req: Request<{}, {}, {}, { page?: number, limit?: number }>, res: Response) => {\n    try {\n\n        const limit = Number(req.query.limit) || 10;\n        const page = Number(req.query.page) || 1;\n        const skip = (page - 1) * limit;\n\n        const [total, subscribers] = await Promise.all([\n            NewsletterSubscriber.countDocuments(),\n            NewsletterSubscriber.find()\n                .select(\"email subscribedAt\")\n                .sort({ createdAt: -1 })\n                .skip(skip)\n                .limit(limit)\n                .lean()\n        ])\n\n        const totalPages = Math.ceil(total / limit);\n\n        res.status(200).json({\n            success: true,\n            message: \"Subscribers fetched successfully.\",\n            data: subscribers,\n            pagination: {\n                currentPage: page,\n                totalPages,\n                hasNextPage: page < totalPages,\n                hasPrevPage: page > 1\n            }\n        })\n\n    } catch (err) {\n        res.status(500).json({\n            success: false,\n            message: \"Internal server error\",\n            error: err instanceof Error ? err.message : \"Something went wrong\"\n        })\n    }\n}","import { z } from \"zod\";\n\nexport const subscribeSchema = z.object({\n    email: z.string({\n        required_error: \"Email is required\"\n    }).email(\"Invalid email format\")\n})\n\n\nexport type SubscribeInput = z.infer<typeof subscribeSchema>; "],"mappings":"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","names":["passport","jwt","refreshToken","Router","model","Schema","model","Schema","passport","z","router","Router","Types","z","Router","router","Router","model","Schema","z","router","Router","passport"]}